<!doctype html>
<head>
  <meta charset="utf-8">
  <title>Proyecto: Un lenguaje de programación :: Eloquent JavaScript</title>
  <link rel=stylesheet href="js/node_modules/codemirror/lib/codemirror.css">
  <script src="js/acorn_codemirror.js"></script>
  <link rel=stylesheet href="css/ejs.css">
  <script src="js/sandbox.js"></script>
  <script src="js/ejs.js"></script>
  <script>var chapNum = 11;var sandboxLoadFiles = ["code/chapter/11_language.js"];</script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-53624335-3', 'auto');
  ga('send', 'pageview');

  </script>
</head>

<article>
<nav>
  <a href="10_modules.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="12_browser.html" title="capítulo siguiente">▶</a>
</nav>

<h1><div class=chap_num>Capítulo 11</div>Proyecto: Un lenguaje de programación</h1>
<blockquote>
<p><a class=p_ident id="p_r+vrGpPPWq" href="#p_r+vrGpPPWq"></a>El evaluador, que determina el significado de las expresiones en un lenguaje de programación, es simplemente otro programa.</p>
 <footer>Hal Abelson and Gerald Sussman, <cite>Structure and Interpretation of Computer Programs</cite></footer>
</blockquote>
<blockquote>
<p><a class=p_ident id="p_OvOFQRYweb" href="#p_OvOFQRYweb"></a>Cuando un estudiante le preguntó al maestro acerca de la naturaleza del ciclo de datos y control, Yuan-Ma respondió "Piensa en un compilador, compilándose."</p>
 <footer>Master Yuan-Ma, <cite>The Book of Programming</cite></footer>
</blockquote>
<p><a class=p_ident id="p_NdDDsmuedf" href="#p_NdDDsmuedf"></a>Construir su propio lenguaje de programación es sorprendentemente fácil (siempre y cuando no apunte demasiado alto) y muy esclarecedor.</p>
<p><a class=p_ident id="p_dRHVP4yGIS" href="#p_dRHVP4yGIS"></a>Lo principal que quiero mostrar en este capítulo es que no hay magia involucrada en la construcción de su propio idioma. A menudo he sentido que algunas invenciones humanas eran tan inmensamente inteligentes y complicadas que nunca sería capaz de entenderlas. Pero con un poco de lectura y retoques, tales cosas a menudo resultan ser bastante mundano.</p>
<p><a class=p_ident id="p_AY1eTWKK2r" href="#p_AY1eTWKK2r"></a>Construiremos un lenguaje de programación llamado "Egg". Será un lenguaje pequeño y sencillo, pero que sea lo suficientemente poderoso para expresar cualquier cálculo que se pueda imaginar. También permitirá la abstracción simple basada en funciones.</p>
<h2 id="parsing"><a class=h_ident id="h_Jg4lG9Tk+3" href="#h_Jg4lG9Tk+3"></a>Analizando</h2>
<p><a class=p_ident id="p_LWCHgQ8jiK" href="#p_LWCHgQ8jiK"></a>La parte más inmediatamente visible de un lenguaje de programación es su sintaxis, o notación. Un analizador es un programa que lee una parte del texto y produce una estructura de datos que refleja la estructura del programa contenido en ese texto. Si el texto no forma un programa válido, el analizador debe quejarse y señalar el error.</p>
<p><a class=p_ident id="p_7Q0cA5YMCB" href="#p_7Q0cA5YMCB"></a>Nuestro lenguaje tendrá una sintaxis simple y uniforme. Todo en "Egg" es una expresión. Una expresión puede ser una variable, un número, una cadena o una aplicación. Las aplicaciones se utilizan para llamar a funciones, pero también para construcciones como <code>if</code> o <code>while</code>.</p>
<p><a class=p_ident id="p_ep+0glVGES" href="#p_ep+0glVGES"></a>Para mantener el analizador simple, las cadenas en "Egg" no soportan nada como escapes de barra invertida. Una cadena es simplemente una secuencia de caracteres que no son comillas dobles, envueltos en comillas dobles. Un número es una secuencia de dígitos. Los nombres de las variables pueden consistir en cualquier carácter que no sea un espacio en blanco y no tenga un significado especial en la sintaxis.</p>
<p><a class=p_ident id="p_vwvgo3jFhV" href="#p_vwvgo3jFhV"></a>Las aplicaciones se escriben de la forma en que están en JavaScript, poniendo paréntesis después de una expresión pudiendo tener cualquier número de argumentos entre esos paréntesis, separados por comas.</p>
<pre>do(define(x, 10),
   if(&gt;(x, 5),
      print("large"),
      print("small")))</pre>
<p><a class=p_ident id="p_yh0b/fAYIh" href="#p_yh0b/fAYIh"></a>La uniformidad del lenguaje "Egg" significa que las cosas que son operadores en JavaScript (como <code>&gt;</code>) son variables normales en este lenguaje, aplicadas como otras funciones. Y puesto que la sintaxis no tiene concepto de un bloque, necesitamos una construcción <code>do</code> para representar hacer varias cosas en secuencia.</p>
<p><a class=p_ident id="p_U5mB4GWXLX" href="#p_U5mB4GWXLX"></a>La estructura de datos que el analizador utilizará para describir un programa consistirá en objetos de expresión, cada uno de los cuales tiene una propiedad <code>type</code> que indica el tipo de expresión que es y otras propiedades para describir su contenido.</p>
<p><a class=p_ident id="p_1s3I5AYr64" href="#p_1s3I5AYr64"></a>Expressions of type <code>"value"</code> represent literal strings
or numbers. Their <code>value</code> property contains the string or number value
that they represent. Expressions of type <code>"word"</code> are used for
identifiers (names). Such objects have a <code>name</code> property that holds
the identifier&#8217;s name as a string. Finally, <code>"apply"</code> expressions
represent applications. They have an <code>operator</code> property that refers
to the expression that is being applied, and they have an <code>args</code> property that
refers to an array of argument expressions.</p>
<p><a class=p_ident id="p_wAreTR3VZi" href="#p_wAreTR3VZi"></a>Las expresiones de tipo <code>"value"</code> representan cadenas literales o números. Su propiedad <code>value</code> contiene el valor de cadena o número que representan. Las expresiones del tipo "<code>word</code>" se utilizan para identificadores (nombres). Tales objetos tienen una propiedad de name que contiene una cadena con su nombre. Finalmente, las expresiones <code>"apply"</code> representan aplicaciones. Tienen una propiedad <code>operator</code> que hace referencia a la expresión que se está aplicando y tienen una propiedad <code>args</code> que hace referencia a una matriz con sus argumentos.</p>
<p><a class=p_ident id="p_8OFZK7W78R" href="#p_8OFZK7W78R"></a>La parte <code>&gt;(x, 5)</code> del programa anterior se representa así:</p>
<pre data-language="application/json" class="snippet cm-s-default"><a class=c_ident id="c_lPJ6z4fyKi" href="#c_lPJ6z4fyKi"></a>{
  <span class="cm-property">type</span>: <span class="cm-string">"apply"</span>,
  <span class="cm-property">operator</span>: {<span class="cm-property">type</span>: <span class="cm-string">"word"</span>, <span class="cm-property">name</span>: <span class="cm-string">">"</span>},
  <span class="cm-property">args</span>: [
    {<span class="cm-property">type</span>: <span class="cm-string">"word"</span>, <span class="cm-property">name</span>: <span class="cm-string">"x"</span>},
    {<span class="cm-property">type</span>: <span class="cm-string">"value"</span>, <span class="cm-property">value</span>: <span class="cm-number">5</span>}
  ]
}</pre>
<p><a class=p_ident id="p_eBsln1ltlZ" href="#p_eBsln1ltlZ"></a>Esta estructura de datos se llama un <em>estructura de árbol</em>. Si usted imagina los objetos como puntos y los enlaces entre ellos como líneas entre esos puntos, tiene una forma de árbol. El hecho de que las expresiones contengan otras expresiones, que a su vez podrían contener más expresiones, es similar al modo en que las ramas se dividen y se dividen de nuevo.</p>
<div class="image">
  <img src="img/syntax_tree.svg" alt="The structure of a syntax tree">
</div>
<p><a class=p_ident id="p_qX7ma0G4cT" href="#p_qX7ma0G4cT"></a>Compare esto con el analizador que escribimos para el formato de archivo de configuración en el <a href="09_regexp.html#ini">Capítulo 9</a>, que tenía una estructura simple: dividió la entrada en líneas y manejó esas líneas una a la vez. Solamente permitia tener alguna forma simples en una linea.</p>
<p><a class=p_ident id="p_6Mz6uGItWm" href="#p_6Mz6uGItWm"></a>Aquí debemos encontrar un enfoque diferente. Las expresiones no se separan en líneas y tienen una estructura recursiva. Las expresiones de la aplicación <em>contienen</em> otras expresiones.</p>
<p><a class=p_ident id="p_Q4qJBrDPcH" href="#p_Q4qJBrDPcH"></a>Afortunadamente, este problema se puede resolver elegantemente escribiendo una función recursiva en el analizador una manera que refleja la naturaleza recursiva de la lengua.</p>
<p><a class=p_ident id="p_b1z6mkbDEm" href="#p_b1z6mkbDEm"></a>Definimos la función <code>parseExpression</code>, que toma una cadena como entrada y devuelve un objeto que contiene la estructura de datos para la expresión al principio de la cadena, junto con la parte de la cadena que queda después de analizar esta expresión. Al analizar las subexpresiones (el argumento a una aplicación, por ejemplo), esta función puede ser llamada de nuevo, dando la expresión del argumento, así como el texto que permanece. Este texto puede a su vez contener más argumentos o puede ser el paréntesis de cierre que termina la lista de argumentos.</p>
<p><a class=p_ident id="p_8Ig2QyzwUD" href="#p_8Ig2QyzwUD"></a>Esta es la primera parte del analizador:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_X80Bp8oPT8" href="#c_X80Bp8oPT8"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseExpression</span>(<span class="cm-def">program</span>) {
  <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">match</span>, <span class="cm-def">expr</span>;
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^"([^"]*)"/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">program</span>))
    <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"value"</span>, <span class="cm-property">value</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">1</span>]};
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^\d+\b/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">program</span>))
    <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"value"</span>, <span class="cm-property">value</span>: <span class="cm-variable">Number</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">0</span>])};
  <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">match</span> <span class="cm-operator">=</span> <span class="cm-string-2">/^[^\s(),"]+/</span>.<span class="cm-property">exec</span>(<span class="cm-variable-2">program</span>))
    <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"word"</span>, <span class="cm-property">name</span>: <span class="cm-variable-2">match</span>[<span class="cm-number">0</span>]};
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Unexpected syntax: "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">program</span>);

  <span class="cm-keyword">return</span> <span class="cm-variable">parseApply</span>(<span class="cm-variable-2">expr</span>, <span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">match</span>[<span class="cm-number">0</span>].<span class="cm-property">length</span>));
}

<span class="cm-keyword">function</span> <span class="cm-variable">skipSpace</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">first</span> <span class="cm-operator">=</span> <span class="cm-variable-2">string</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">first</span> <span class="cm-operator">==</span> <span class="cm-operator">-</span><span class="cm-number">1</span>) <span class="cm-keyword">return</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">first</span>);
}</pre>
<p><a class=p_ident id="p_1cskRUy8p3" href="#p_1cskRUy8p3"></a>Debido a que "Egg" permite cualquier cantidad de espacio en blanco entre sus elementos, tenemos que cortar repetidamente el espacio en blanco desde el inicio de la cadena del programa. Para esto nos ayuda la función <code>skipSpace</code>.</p>
<p><a class=p_ident id="p_K5EOoYuoeL" href="#p_K5EOoYuoeL"></a>Después de salterse cualquier espacio en blanco, <code>parseExpression</code> utiliza tres expresiones regulares para detectar los tres elementos simples (atomic) que "Egg" soporta: cadenas, números y palabras. El analizador construye un tipo diferente de estructura de datos dependiendo de cuál coincide. Si la entrada no coincide con una de estas tres formas, no es una expresión válida y el analizador genera un error. <code>SyntaxError</code> es un tipo de objeto de error estándar, que se genera cuando se intenta ejecutar un programa no válido en JavaScript.</p>
<p><a class=p_ident id="p_PmRqrj1NW7" href="#p_PmRqrj1NW7"></a>Podemos entonces cortar la parte que coincide con una cadena en el programa y pasar que, junto con el objeto de la expresión, a <code>parseApply</code>, que comprueba si la expresión es una aplicación. Si es así, analiza una lista de argumentos entre paréntesis.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_8XJhY9YZ7z" href="#c_8XJhY9YZ7z"></a><span class="cm-keyword">function</span> <span class="cm-variable">parseApply</span>(<span class="cm-def">expr</span>, <span class="cm-def">program</span>) {
  <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">!=</span> <span class="cm-string">"("</span>)
    <span class="cm-keyword">return</span> {<span class="cm-property">expr</span>: <span class="cm-variable-2">expr</span>, <span class="cm-property">rest</span>: <span class="cm-variable-2">program</span>};

  <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
  <span class="cm-variable-2">expr</span> <span class="cm-operator">=</span> {<span class="cm-property">type</span>: <span class="cm-string">"apply"</span>, <span class="cm-property">operator</span>: <span class="cm-variable-2">expr</span>, <span class="cm-property">args</span>: []};
  <span class="cm-keyword">while</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">!=</span> <span class="cm-string">")"</span>) {
    <span class="cm-keyword">var</span> <span class="cm-def">arg</span> <span class="cm-operator">=</span> <span class="cm-variable">parseExpression</span>(<span class="cm-variable-2">program</span>);
    <span class="cm-variable-2">expr</span>.<span class="cm-property">args</span>.<span class="cm-property">push</span>(<span class="cm-variable-2">arg</span>.<span class="cm-property">expr</span>);
    <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">arg</span>.<span class="cm-property">rest</span>);
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">==</span> <span class="cm-string">","</span>)
      <span class="cm-variable-2">program</span> <span class="cm-operator">=</span> <span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
    <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable-2">program</span>[<span class="cm-number">0</span>] <span class="cm-operator">!=</span> <span class="cm-string">")"</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Expected ',' or ')'"</span>);
  }
  <span class="cm-keyword">return</span> <span class="cm-variable">parseApply</span>(<span class="cm-variable-2">expr</span>, <span class="cm-variable-2">program</span>.<span class="cm-property">slice</span>(<span class="cm-number">1</span>));
}</pre>
<p><a class=p_ident id="p_3Aq+XX2jG3" href="#p_3Aq+XX2jG3"></a>Si el siguiente carácter del programa no es un paréntesis de apertura, esto no es una aplicación y <code>parseApply</code> simplemente devuelve la expresión que se le dio.</p>
<p><a class=p_ident id="p_78ubwMfArs" href="#p_78ubwMfArs"></a>De lo contrario, omite el paréntesis de apertura y crea el objeto de estructura de árbol para esta expresión de aplicación. A continuación, recursivamente llama a <code>ParseExpression</code> para analizar cada argumento hasta que se encuentra un paréntesis de cierre. La recursión es indirecta, a través de <code>parseApply</code> y <code>parseExpression</code> llamándose entre sí.</p>
<p><a class=p_ident id="p_U3xcmi1mE5" href="#p_U3xcmi1mE5"></a>Because an application expression can itself be applied (such as in
<code>multiplier(2)(1)</code>), <code>parseApply</code> must, after it has parsed an
application, call itself again to check whether another pair of
parentheses follows.</p>
<p><a class=p_ident id="p_90G+9Tj0eN" href="#p_90G+9Tj0eN"></a>Porque una expresión de aplicación puede aplicarse por sí misma (como en <code>multiplier(2)(1)</code>), <code>parseApply</code> debe, después de haber analizado una aplicación, volver a llamar para comprobar si hay otro par de paréntesis.</p>
<p><a class=p_ident id="p_89g4z+3rO6" href="#p_89g4z+3rO6"></a>Esto es todo lo que necesita el analizador "Egg". Lo envolvemos en una conveniente función de análisis que verifica que ha llegado al final de la cadena de entrada después de analizar la expresión (un programa "Egg" es una sola expresión), y que nos da la estructura de datos del programa.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_zZN6K7x2hM" href="#c_zZN6K7x2hM"></a><span class="cm-keyword">function</span> <span class="cm-variable">parse</span>(<span class="cm-def">program</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">result</span> <span class="cm-operator">=</span> <span class="cm-variable">parseExpression</span>(<span class="cm-variable-2">program</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable">skipSpace</span>(<span class="cm-variable-2">result</span>.<span class="cm-property">rest</span>).<span class="cm-property">length</span> <span class="cm-operator">></span> <span class="cm-number">0</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Unexpected text after program"</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">result</span>.<span class="cm-property">expr</span>;
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">"+(a, 10)"</span>));
<span class="cm-comment">// → {type: "apply",</span>
<span class="cm-comment">//    operator: {type: "word", name: "+"},</span>
<span class="cm-comment">//    args: [{type: "word", name: "a"},</span>
<span class="cm-comment">//           {type: "value", value: 10}]}</span></pre>
<p><a class=p_ident id="p_KlqKEaXr4c" href="#p_KlqKEaXr4c"></a>¡Funciona! No nos da información muy útil cuando falla y no almacena la línea y la columna en la que empieza cada expresión, lo que podría ser útil cuando se reportan errores más tarde, pero es lo suficientemente bueno para nuestros propósito.</p>
<h2><a class=h_ident id="h_lI3Fc6r+GN" href="#h_lI3Fc6r+GN"></a>El evaluador</h2>
<p><a class=p_ident id="p_zh35S/U09t" href="#p_zh35S/U09t"></a>¿Qué podemos hacer con la estructura de árbol del programa? Correrla, por supuesto! Y eso es lo que hace el evaluador. Se le asigna una estructura de árbol y un objeto de entorno que asocia nombres con valores y evaluará la expresión que representa el árbol y devolverá el valor que produce.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_4PzV57jGzX" href="#c_4PzV57jGzX"></a><span class="cm-keyword">function</span> <span class="cm-variable">evaluate</span>(<span class="cm-def">expr</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">switch</span>(<span class="cm-variable-2">expr</span>.<span class="cm-property">type</span>) {
    <span class="cm-keyword">case</span> <span class="cm-string">"value"</span>:
      <span class="cm-keyword">return</span> <span class="cm-variable-2">expr</span>.<span class="cm-property">value</span>;

    <span class="cm-keyword">case</span> <span class="cm-string">"word"</span>:
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">expr</span>.<span class="cm-property">name</span> <span class="cm-keyword">in</span> <span class="cm-variable-2">env</span>)
        <span class="cm-keyword">return</span> <span class="cm-variable-2">env</span>[<span class="cm-variable-2">expr</span>.<span class="cm-property">name</span>];
      <span class="cm-keyword">else</span>
        <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">ReferenceError</span>(<span class="cm-string">"Undefined variable: "</span> <span class="cm-operator">+</span>
                                 <span class="cm-variable-2">expr</span>.<span class="cm-property">name</span>);
    <span class="cm-keyword">case</span> <span class="cm-string">"apply"</span>:
      <span class="cm-keyword">if</span> (<span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>.<span class="cm-property">type</span> <span class="cm-operator">==</span> <span class="cm-string">"word"</span> <span class="cm-operator">&amp;&amp;</span>
          <span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>.<span class="cm-property">name</span> <span class="cm-keyword">in</span> <span class="cm-variable">specialForms</span>)
        <span class="cm-keyword">return</span> <span class="cm-variable">specialForms</span>[<span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>.<span class="cm-property">name</span>](<span class="cm-variable-2">expr</span>.<span class="cm-property">args</span>,
                                                <span class="cm-variable-2">env</span>);
      <span class="cm-keyword">var</span> <span class="cm-def">op</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">expr</span>.<span class="cm-property">operator</span>, <span class="cm-variable-2">env</span>);
      <span class="cm-keyword">if</span> (<span class="cm-keyword">typeof</span> <span class="cm-variable-2">op</span> <span class="cm-operator">!=</span> <span class="cm-string">"function"</span>)
        <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">TypeError</span>(<span class="cm-string">"Applying a non-function."</span>);
      <span class="cm-keyword">return</span> <span class="cm-variable-2">op</span>.<span class="cm-property">apply</span>(<span class="cm-atom">null</span>, <span class="cm-variable-2">expr</span>.<span class="cm-property">args</span>.<span class="cm-property">map</span>(<span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
        <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">arg</span>, <span class="cm-variable-2">env</span>);
      }));
  }
}

<span class="cm-keyword">var</span> <span class="cm-variable">specialForms</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);</pre>
<p><a class=p_ident id="p_vdvuwNIZah" href="#p_vdvuwNIZah"></a>El evaluador tiene código para cada uno de los tipos de expresiones. Una expresión de valor literal simplemente produce su valor. (Por ejemplo, la expresión 100 equivale al número 100.) Para una variable, debemos comprobar si está realmente definida en el entorno y, si es así, buscar el valor de la variable.</p>
<p><a class=p_ident id="p_HZh/oESbE1" href="#p_HZh/oESbE1"></a>Las aplicaciones están más comprometidas. Si son una forma especial, como <code>if</code>, no evaluamos nada y simplemente pasamos las expresiones de argumento, junto con el entorno, a la función que maneja esta estructura. Si es una llamada normal, evaluamos al operador, verificamos que es una función y lo llamamos con el resultado de evaluar los argumentos.</p>
<p><a class=p_ident id="p_hf1HR7WfrQ" href="#p_hf1HR7WfrQ"></a>Utilizaremos funciones simple de JavaScript para representar los valores de funciones de "Egg". Volveremos a esto <a href="11_language.html#egg_fun">más adelante</a>, cuando definamos la forma especial de llamar funciones.</p>
<p><a class=p_ident id="p_acLr1gbIF+" href="#p_acLr1gbIF+"></a>La estructura recursiva de <code>evaluate</code> se asemeja a la estructura similar de <code>parse</code>. Ambos reflejan la estructura del lenguaje mismo. También sería posible integrar el <code>parse</code> con el <code>evaluate</code> y evaluar durante el análisis sintáctico, pero dividirlo de esta manera hace que el programa sea más legible.</p>
<p><a class=p_ident id="p_YL/SkpZx0H" href="#p_YL/SkpZx0H"></a>Esto es realmente todo lo que se necesita interpretar "Egg". Así de simple. Sin embargo, sin definir algunas formas especiales y agregar algunas utilidades al entorno, todavía no se puede hacer nada con este lenguaje.</p>
<h2><a class=h_ident id="h_JOCrYKZbDr" href="#h_JOCrYKZbDr"></a>Special forms</h2>
<p><a class=p_ident id="p_ctw/upI27I" href="#p_ctw/upI27I"></a>El objeto <code>specialForms</code> se utiliza para definir sintaxis especial en "Egg". Asocia palabras con funciones que evalúan tales formas especiales. Actualmente está vacío. Añadamos algunas formas.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_keHNLB7iSD" href="#c_keHNLB7iSD"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"if"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-number">3</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Bad number of args to if"</span>);

  <span class="cm-keyword">if</span> (<span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">0</span>], <span class="cm-variable-2">env</span>) <span class="cm-operator">!==</span> <span class="cm-atom">false</span>)
    <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">1</span>], <span class="cm-variable-2">env</span>);
  <span class="cm-keyword">else</span>
    <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">2</span>], <span class="cm-variable-2">env</span>);
};</pre>
<p><a class=p_ident id="p_HdCtE0tZYl" href="#p_HdCtE0tZYl"></a>El Constructor <code>if</code> de "Egg" espera exactamente tres argumentos. Se evaluará el primero, y si el resultado no es el valor <code>false</code>, se evaluará el segundo. Si no, el tercero se evaluara. Esta forma es más similar a operador ternario <code>?:</code> que al de JavaScript <code>if</code>. Es una expresión, no una declaración, y produce un valor, es decir, el resultado del segundo o tercer argumento.</p>
<p><a class=p_ident id="p_T8DxtrOCU1" href="#p_T8DxtrOCU1"></a>"Egg" difiere de JavaScript en cómo maneja el valor de la condición <code>if</code>. No tratará las cosas como cero o la cadena vacía como <code>false</code>, sólo el valor preciso <code>false</code>.</p>
<p><a class=p_ident id="p_q4X/kmv6pB" href="#p_q4X/kmv6pB"></a>La razón por la que tenemos que representar <code>if</code> como una estructura especial, en lugar de una función regular, es que todos los argumentos a las funciones se evalúan antes de que se llame a la función, mientras que <code>if</code> debería evaluar sólo su segundo o su tercer argumento, dependiendo del valor del primero.</p>
<p><a class=p_ident id="p_s9xxz3sgT/" href="#p_s9xxz3sgT/"></a>La estructura de <code>while</code> es similar.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_kBhjZeVpOd" href="#c_kBhjZeVpOd"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"while"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-number">2</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Bad number of args to while"</span>);

  <span class="cm-keyword">while</span> (<span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">0</span>], <span class="cm-variable-2">env</span>) <span class="cm-operator">!==</span> <span class="cm-atom">false</span>)
    <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">1</span>], <span class="cm-variable-2">env</span>);

  <span class="cm-comment">// Como undefined no existe en Egg, devolvemos false,</span>
  <span class="cm-comment">// para la falta de resultados válidos</span>
  <span class="cm-keyword">return</span> <span class="cm-atom">false</span>;
};</pre>
<p><a class=p_ident id="p_TpJg9SiWJW" href="#p_TpJg9SiWJW"></a>Otro bloque de construcción básico es <code>do</code>, que ejecuta todos sus argumentos de arriba a abajo. Su valor es el valor producido por el último argumento.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_C0SLsNu6uq" href="#c_C0SLsNu6uq"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"do"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">value</span> <span class="cm-operator">=</span> <span class="cm-atom">false</span>;
  <span class="cm-variable-2">args</span>.<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">arg</span>) {
    <span class="cm-variable-2">value</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">arg</span>, <span class="cm-variable-2">env</span>);
  });
  <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span>;
};</pre>
<p><a class=p_ident id="p_p3K5iHWfUQ" href="#p_p3K5iHWfUQ"></a>Para poder crear variables y darles nuevos valores, también creamos una <code>specialForms</code> llamada <code>define</code>. Espera una palabra como su primer argumento y una expresión que produce el valor para asignar a esa palabra como su segundo argumento. Dado que <code>define</code>, como toda una expresión, debe devolver un valor. Vamos a hacer que devuelva el valor que se asignó (Como el operador <code>=</code> de JavaScript)</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_4QghGMwc4p" href="#c_4QghGMwc4p"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"define"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-number">2</span> <span class="cm-operator">||</span> <span class="cm-variable-2">args</span>[<span class="cm-number">0</span>].<span class="cm-property">type</span> <span class="cm-operator">!=</span> <span class="cm-string">"word"</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Bad use of define"</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">value</span> <span class="cm-operator">=</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">args</span>[<span class="cm-number">1</span>], <span class="cm-variable-2">env</span>);
  <span class="cm-variable-2">env</span>[<span class="cm-variable-2">args</span>[<span class="cm-number">0</span>].<span class="cm-property">name</span>] <span class="cm-operator">=</span> <span class="cm-variable-2">value</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span>;
};</pre>
<h2><a class=h_ident id="h_QDYVZFuV/L" href="#h_QDYVZFuV/L"></a>El entorno</h2>
<p><a class=p_ident id="p_OvjVarnYbm" href="#p_OvjVarnYbm"></a>El entorno aceptado por el evaluador es un objeto con propiedades cuyos nombres corresponden a nombres de variables y cuyos valores corresponden a los valores a los que están vinculadas. Vamos a definir un objeto de entorno para representar el ámbito global.</p>
<p><a class=p_ident id="p_b3b8HuKUtZ" href="#p_b3b8HuKUtZ"></a>Para poder usar la construcción <code>if</code> que acabamos de definir, debemos tener acceso a valores booleanos. Como sólo tiene dos valores, no necesitamos sintaxis especial para ellos. Simplemente enlazamos dos variables a los valores <code>true</code> y <code>false</code> y los usamos.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_hR54TW9tph" href="#c_hR54TW9tph"></a><span class="cm-keyword">var</span> <span class="cm-variable">topEnv</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-atom">null</span>);

<span class="cm-variable">topEnv</span>[<span class="cm-string">"true"</span>] <span class="cm-operator">=</span> <span class="cm-atom">true</span>;
<span class="cm-variable">topEnv</span>[<span class="cm-string">"false"</span>] <span class="cm-operator">=</span> <span class="cm-atom">false</span>;</pre>
<p><a class=p_ident id="p_cfbJP/t15X" href="#p_cfbJP/t15X"></a>Ahora podemos evaluar un expresión y devolver un valor boleano.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_FxZR6Fdmd1" href="#c_FxZR6Fdmd1"></a><span class="cm-keyword">var</span> <span class="cm-variable">prog</span> <span class="cm-operator">=</span> <span class="cm-variable">parse</span>(<span class="cm-string">"if(true, false, true)"</span>);
<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">evaluate</span>(<span class="cm-variable">prog</span>, <span class="cm-variable">topEnv</span>));
<span class="cm-comment">// → false</span></pre>
<p><a class=p_ident id="p_KjdoKthut1" href="#p_KjdoKthut1"></a>Para facilitar aritmética y operadores de comparación, también agregaremos algunos valores de función al entorno. En interés de mantener el código corto, vamos a utilizar <code>new Function</code> para sintetizar un montón de funciones de operador en un bucle, en lugar de definir todos ellos individualmente.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_tur1GafQLT" href="#c_tur1GafQLT"></a>[<span class="cm-string">"+"</span>, <span class="cm-string">"-"</span>, <span class="cm-string">"*"</span>, <span class="cm-string">"/"</span>, <span class="cm-string">"=="</span>, <span class="cm-string">"&lt;"</span>, <span class="cm-string">">"</span>].<span class="cm-property">forEach</span>(<span class="cm-keyword">function</span>(<span class="cm-def">op</span>) {
  <span class="cm-variable">topEnv</span>[<span class="cm-variable-2">op</span>] <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Function</span>(<span class="cm-string">"a, b"</span>, <span class="cm-string">"return a "</span> <span class="cm-operator">+</span> <span class="cm-variable-2">op</span> <span class="cm-operator">+</span> <span class="cm-string">" b;"</span>);
});</pre>
<p><a class=p_ident id="p_9uGVVJbjO3" href="#p_9uGVVJbjO3"></a>También es muy útiluna forma de mostrar valores de salida, así que vamos a envolver <code>console.log</code> en una función y lo llamamos <code>print</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_o0VLFoQzPE" href="#c_o0VLFoQzPE"></a><span class="cm-variable">topEnv</span>[<span class="cm-string">"print"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">value</span>) {
  <span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable-2">value</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable-2">value</span>;
};</pre>
<p><a class=p_ident id="p_LH6YpaOahi" href="#p_LH6YpaOahi"></a>Eso nos da suficientes herramientas para escribir programas sencillos. La siguiente función <code>run</code> proporciona una forma conveniente de escribirlos y ejecutarlos. Crea un nuevo ámbito y analiza y evalúa las cadenas que le damos como un solo programa.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_hH6wAg7pwu" href="#c_hH6wAg7pwu"></a><span class="cm-keyword">function</span> <span class="cm-variable">run</span>() {
  <span class="cm-keyword">var</span> <span class="cm-def">env</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-variable">topEnv</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">program</span> <span class="cm-operator">=</span> <span class="cm-variable">Array</span>.<span class="cm-property">prototype</span>.<span class="cm-property">slice</span>
    .<span class="cm-property">call</span>(<span class="cm-variable-2">arguments</span>, <span class="cm-number">0</span>).<span class="cm-property">join</span>(<span class="cm-string">"\n"</span>);
  <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable">parse</span>(<span class="cm-variable-2">program</span>), <span class="cm-variable-2">env</span>);
}</pre>
<p><a class=p_ident id="p_R50aeJSlIs" href="#p_R50aeJSlIs"></a>El uso de <code>Array.prototype.slice.call</code> es un truco para convertir un objeto en array-like(similar o que se asemeja a un array), con tantos elementos como <code>arguments</code>, en una Array así que podemos llamar a <code>join</code>. Toma todos los <code>arguments</code> dados para ejecutarlos y los trata como las líneas de un programa.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_rq2hAMfF5N" href="#c_rq2hAMfF5N"></a><span class="cm-variable">run</span>(<span class="cm-string">"do(define(total, 0),"</span>,
    <span class="cm-string">"   define(count, 1),"</span>,
    <span class="cm-string">"   while(&lt;(count, 11),"</span>,
    <span class="cm-string">"         do(define(total, +(total, count)),"</span>,
    <span class="cm-string">"            define(count, +(count, 1)))),"</span>,
    <span class="cm-string">"   print(total))"</span>);
<span class="cm-comment">// → 55</span></pre>
<p><a class=p_ident id="p_xNJMDZFJNP" href="#p_xNJMDZFJNP"></a>Este es el programa que hemos visto varias veces antes, que calcula la suma de los números 1 a 10, expresada en "Egg". Es claramente más feo que el programa JavaScript equivalente, pero no está mal para un lenguaje implementado en menos de 150 líneas de código.</p>
<h2 id="egg_fun"><a class=h_ident id="h_H0l5He7QIh" href="#h_H0l5He7QIh"></a>Funciones</h2>
<p><a class=p_ident id="p_qQ/W0VBB7l" href="#p_qQ/W0VBB7l"></a>Un lenguaje de programación sin funciones es un lenguaje verdaderamente pobre</p>
<p><a class=p_ident id="p_Knv8+HvQ29" href="#p_Knv8+HvQ29"></a>Afortunadamente, no es difícil añadir una constructor <code>fun</code>, que trata su último argumento como el cuerpo de la función y todos los argumentos anteriores como los nombres de los argumentos de la función.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_mbreVUDgQo" href="#c_mbreVUDgQo"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"fun"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-keyword">if</span> (<span class="cm-operator">!</span><span class="cm-variable-2">args</span>.<span class="cm-property">length</span>)
    <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Functions need a body"</span>);
  <span class="cm-keyword">function</span> <span class="cm-def">name</span>(<span class="cm-def">expr</span>) {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">expr</span>.<span class="cm-property">type</span> <span class="cm-operator">!=</span> <span class="cm-string">"word"</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">SyntaxError</span>(<span class="cm-string">"Arg names must be words"</span>);
    <span class="cm-keyword">return</span> <span class="cm-variable-2">expr</span>.<span class="cm-property">name</span>;
  }
  <span class="cm-keyword">var</span> <span class="cm-def">argNames</span> <span class="cm-operator">=</span> <span class="cm-variable-2">args</span>.<span class="cm-property">slice</span>(<span class="cm-number">0</span>, <span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>).<span class="cm-property">map</span>(<span class="cm-variable-2">name</span>);
  <span class="cm-keyword">var</span> <span class="cm-def">body</span> <span class="cm-operator">=</span> <span class="cm-variable-2">args</span>[<span class="cm-variable-2">args</span>.<span class="cm-property">length</span> <span class="cm-operator">-</span> <span class="cm-number">1</span>];

  <span class="cm-keyword">return</span> <span class="cm-keyword">function</span>() {
    <span class="cm-keyword">if</span> (<span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span> <span class="cm-operator">!=</span> <span class="cm-variable-2">argNames</span>.<span class="cm-property">length</span>)
      <span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">TypeError</span>(<span class="cm-string">"Wrong number of arguments"</span>);
    <span class="cm-keyword">var</span> <span class="cm-def">localEnv</span> <span class="cm-operator">=</span> <span class="cm-variable">Object</span>.<span class="cm-property">create</span>(<span class="cm-variable-2">env</span>);
    <span class="cm-keyword">for</span> (<span class="cm-keyword">var</span> <span class="cm-def">i</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>; <span class="cm-variable-2">i</span> <span class="cm-operator">&lt;</span> <span class="cm-variable-2">arguments</span>.<span class="cm-property">length</span>; <span class="cm-variable-2">i</span><span class="cm-operator">++</span>)
      <span class="cm-variable-2">localEnv</span>[<span class="cm-variable-2">argNames</span>[<span class="cm-variable-2">i</span>]] <span class="cm-operator">=</span> <span class="cm-variable-2">arguments</span>[<span class="cm-variable-2">i</span>];
    <span class="cm-keyword">return</span> <span class="cm-variable">evaluate</span>(<span class="cm-variable-2">body</span>, <span class="cm-variable-2">localEnv</span>);
  };
};</pre>
<p><a class=p_ident id="p_KHZSg7dw/e" href="#p_KHZSg7dw/e"></a>Las funciones en "Egg" tienen su propio entorno local, al igual que en JavaScript. Utilizamos <code>Object.create</code> para crear un nuevo objeto que tenga acceso a las variables del entorno externo (su prototipo) pero que también pueda contener nuevas variables sin modificar al ámbito global.</p>
<p><a class=p_ident id="p_khpPxAtBFH" href="#p_khpPxAtBFH"></a>La función creada por el objecto <code>fun</code> crea este entorno local y le agrega las variables por argumentos. A continuación, evalúa el cuerpo de la función en este entorno y devuelve el resultado.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_6wz7YvjcKo" href="#c_6wz7YvjcKo"></a><span class="cm-variable">run</span>(<span class="cm-string">"do(define(plusOne, fun(a, +(a, 1))),"</span>,
    <span class="cm-string">"   print(plusOne(10)))"</span>);
<span class="cm-comment">// → 11</span>

<span class="cm-variable">run</span>(<span class="cm-string">"do(define(pow, fun(base, exp,"</span>,
    <span class="cm-string">"     if(==(exp, 0),"</span>,
    <span class="cm-string">"        1,"</span>,
    <span class="cm-string">"        *(base, pow(base, -(exp, 1)))))),"</span>,
    <span class="cm-string">"   print(pow(2, 10)))"</span>);
<span class="cm-comment">// → 1024</span></pre>
<h2><a class=h_ident id="h_QZp+1BKgLP" href="#h_QZp+1BKgLP"></a>Compilación</h2>
<p><a class=p_ident id="p_Rm6AA2XWE7" href="#p_Rm6AA2XWE7"></a>Lo que hemos construido es un intérprete. Durante la evaluación, actúa directamente sobre la representación del programa producido por el analizador.</p>
<p><a class=p_ident id="p_aFJDPvYME4" href="#p_aFJDPvYME4"></a><em>Compilación</em> es el proceso de añadir otro paso entre el análisis y el funcionamiento de un programa, que transforma el programa en algo que puede ser evaluado de manera más eficiente haciendo todo el trabajo posible de antemano. Por ejemplo, en lenguajes bien diseñados es obvio, para cada uso de una variable, a qué variable se refiere, sin ejecutar realmente el programa. Esto puede usarse para evitar buscar la variable por nombre cada vez que se accede y para buscarla directamente desde una ubicación de memoria predeterminada.</p>
<p><a class=p_ident id="p_8c81+Piyoz" href="#p_8c81+Piyoz"></a>Traditionally, compilationTradicionalmente, la compilación implica convertir el programa en código de máquina, el formato en bruto que el procesador de una computadora puede ejecutar. Pero cualquier proceso que convierte un programa en una representación diferente puede considerarse como compilación.</p>
<p><a class=p_ident id="p_EQ7lMXgnsQ" href="#p_EQ7lMXgnsQ"></a>Sería posible escribir una estrategia de evaluación alternativa para "Egg", una que primero convierta el programa a un programa JavaScript, utilice una nueva Función para invocar al compilador de JavaScript y luego ejecute el resultado. Cuando se haga bien, esto hará que "Egg" corra muy rápido sin dejar de ser muy sencillo de implementar.</p>
<p><a class=p_ident id="p_TuY1QXe+pB" href="#p_TuY1QXe+pB"></a>Si está interesado en este tema y está dispuesto a dedicar algo de tiempo a ello, le animo a que intente implementar un compilador como un ejercicio.</p>
<h2><a class=h_ident id="h_W74/YPlDXS" href="#h_W74/YPlDXS"></a>Trampeando</h2>
<p><a class=p_ident id="p_xNjkXQlvyg" href="#p_xNjkXQlvyg"></a>Cuando definimos <code>if</code> y <code>while</code>, probablemente notó que eran envolturas más o menos triviales alrededor de los propios <code>if</code> y <code>while</code> de JavaScript. Del mismo modo, los valores de "Egg" son sólo antiguos valores de JavaScript.</p>
<p><a class=p_ident id="p_lGGGT35K5b" href="#p_lGGGT35K5b"></a>Si comparas la implementación de Egg, construida por encima de JavaScript, con la cantidad de trabajo y complejidad requerida para construir un lenguaje de programación directamente en la funcionalidad bruta proporcionada por una máquina, la diferencia es enorme. Independientemente, este ejemplo esperamos le dio una impresión de la forma en que funcionan los lenguajes de programación.</p>
<p><a class=p_ident id="p_DFqolEmN8L" href="#p_DFqolEmN8L"></a>Y cuando se trata de hacer algo, hacer trampa es más eficaz que hacer todo tú mismo. Aunque el lenguaje de juguete de este capítulo no hace nada que no se pueda hacer mejor en JavaScript, hay situaciones en las que escribir lenguajes pequeños ayuda a realizar un trabajo real.</p>
<p><a class=p_ident id="p_VXRQm0WUZD" href="#p_VXRQm0WUZD"></a>Tal lenguaje no tiene que parecerse a un lenguaje de programación típico. Si JavaScript no viene equipado con expresiones regulares, puede escribir su propio analizador y evaluador para tal sublenguaje.</p>
<p><a class=p_ident id="p_4Bw+PR9HAh" href="#p_4Bw+PR9HAh"></a>O imagínese que está construyendo un gigantesco dinosaurio robótico y necesita programar su comportamiento. JavaScript podría no ser la forma más efectiva de hacerlo. En su lugar, puede optar por un idioma que tenga el siguiente aspecto:</p>
<pre>behavior walk
  perform when
    destination ahead
  actions
    move left-foot
    move right-foot

behavior attack
  perform when
    Godzilla in-view
  actions
    fire laser-eyes
    launch arm-rockets</pre>
<p><a class=p_ident id="p_C0dzBDL4SR" href="#p_C0dzBDL4SR"></a>Esto es lo que se suele llamar un <em>lenguaje específico del dominio</em>, un lenguaje adaptado para expresar un estrecho dominio del conocimiento. Tal lenguaje puede ser más expresivo que un lenguaje de propósito general porque está diseñado para expresar exactamente las cosas que necesitan expresarse en su dominio y nada más.</p>
<h2><a class=h_ident id="h_tkm7ntLto1" href="#h_tkm7ntLto1"></a>Ejercicios</h2>
<h3><a class=h_ident id="h_uQzJv9I1Z6" href="#h_uQzJv9I1Z6"></a>Arrays</h3>
<p><a class=p_ident id="p_YuKpxqlanO" href="#p_YuKpxqlanO"></a>Agregue soporte para arrays a "Egg" agregando las siguientes tres funciones al ámbito superior: <code>array (...)</code> para construir una matriz que contenga el valor de sus argumentos, <code>length(array)</code> para obtener la longitud de una matriz y <code>element(array, n)</code> para buscar la posición del elemento en el array.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_gABd/rFKxh" href="#c_gABd/rFKxh"></a><span class="cm-comment">// Modify these definitions...</span>

<span class="cm-variable">topEnv</span>[<span class="cm-string">"array"</span>] <span class="cm-operator">=</span> <span class="cm-string">"..."</span>;

<span class="cm-variable">topEnv</span>[<span class="cm-string">"length"</span>] <span class="cm-operator">=</span> <span class="cm-string">"..."</span>;

<span class="cm-variable">topEnv</span>[<span class="cm-string">"element"</span>] <span class="cm-operator">=</span> <span class="cm-string">"..."</span>;

<span class="cm-variable">run</span>(<span class="cm-string">"do(define(sum, fun(array,"</span>,
    <span class="cm-string">"     do(define(i, 0),"</span>,
    <span class="cm-string">"        define(sum, 0),"</span>,
    <span class="cm-string">"        while(&lt;(i, length(array)),"</span>,
    <span class="cm-string">"          do(define(sum, +(sum, element(array, i))),"</span>,
    <span class="cm-string">"             define(i, +(i, 1)))),"</span>,
    <span class="cm-string">"        sum))),"</span>,
    <span class="cm-string">"   print(sum(array(1, 2, 3))))"</span>);
<span class="cm-comment">// → 6</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_V6CA9sjtEY" href="#p_V6CA9sjtEY"></a>La forma más sencilla de hacerlo es representar arrays de "Egg" con arrays de JavaScript.</p>
<p><a class=p_ident id="p_OcXjudKiv6" href="#p_OcXjudKiv6"></a>Los valores agregados al entorno superior deben ser funciones. <code>Array.prototype.slice</code> se puede utilizar para convertir <code>arguments</code> en un objecto array.</p>
</div></div>
<h3><a class=h_ident id="h_hOd+yVxaku" href="#h_hOd+yVxaku"></a>Closure</h3>
<p><a class=p_ident id="p_fppmSSGuOO" href="#p_fppmSSGuOO"></a>La forma en que hemos definido <code>fun</code> permite a las funciones de "Egg" "cerrar" el entorno, permitiendo que el cuerpo de la función use valores locales que eran visibles en el momento en que se definió la función, al igual que las funciones de JavaScript.</p>
<p><a class=p_ident id="p_tI5o4gZUF5" href="#p_tI5o4gZUF5"></a>El siguiente programa lo ilustra: la función <code>f</code> devuelve una función que añade su argumento como argumentos de  <code>f</code>, lo que significa que necesita acceso al ámbito local dentro de <code>f</code> para poder utilizar la variable <code>a</code>.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_o9oG9G4lmQ" href="#c_o9oG9G4lmQ"></a><span class="cm-variable">run</span>(<span class="cm-string">"do(define(f, fun(a, fun(b, +(a, b)))),"</span>,
    <span class="cm-string">"   print(f(4)(5)))"</span>);
<span class="cm-comment">// → 9</span></pre>
<p><a class=p_ident id="p_llqh3zYfuF" href="#p_llqh3zYfuF"></a>Vuelva a la definición de <code>fun</code> y explique qué mecanismo hace que funcione.</p>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_zt/gMKW0Dc" href="#p_zt/gMKW0Dc"></a>Una vez más, estamos montando sobre un mecanismo JavaScript para obtener la característica equivalente en "Egg". Se pasan funciones especiales al entorno local en el que se evalúan para que puedan evaluar subfunciones dentro de ese entorno. La función devuelta por <code>fun</code> actua sobre el argumento <code>env</code> que se da a su función enclosing y usa eso, para crear el entorno local de la función cuando es llamada.</p>
<p><a class=p_ident id="p_ZUZpVdQzvJ" href="#p_ZUZpVdQzvJ"></a>Esto significa que el prototype del entorno local será el entorno en el que se creó la función, lo que hace posible acceder a las variables en ese entorno desde la función. Esto es todo lo que hay que hacer para implementar el Closure (aunque para compilarlo de una manera que es realmente eficiente, tendría que hacer un poco más de trabajo).</p>
</div></div>
<h3><a class=h_ident id="h_BU3lBD6Cl5" href="#h_BU3lBD6Cl5"></a>Comentarios</h3>
<p><a class=p_ident id="p_O8y2A3uI5s" href="#p_O8y2A3uI5s"></a>Sería bueno si pudiéramos escribir comentarios en "Egg". Si nosotros encontramos el hash (<code>#</code>), podríamos tratar el resto de la línea como un comentario e ignorarlo, similar a <code>//</code> en JavaScript.</p>
<p><a class=p_ident id="p_PKJ2y40E4f" href="#p_PKJ2y40E4f"></a>No tenemos que hacer grandes cambios en el analizador para apoyar esto. Podemos simplemente cambiar <code>skipSpace</code> para omitir los comentarios como si fueran espacios en blanco para que todos los puntos donde <code>skipSpace</code> se llama ahora también saltarán los comentarios. Haga este cambio.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_b6WZ6iMiNq" href="#c_b6WZ6iMiNq"></a><span class="cm-comment">// This is the old skipSpace. Modify it...</span>
<span class="cm-keyword">function</span> <span class="cm-variable">skipSpace</span>(<span class="cm-def">string</span>) {
  <span class="cm-keyword">var</span> <span class="cm-def">first</span> <span class="cm-operator">=</span> <span class="cm-variable-2">string</span>.<span class="cm-property">search</span>(<span class="cm-string-2">/\S/</span>);
  <span class="cm-keyword">if</span> (<span class="cm-variable-2">first</span> <span class="cm-operator">==</span> <span class="cm-operator">-</span><span class="cm-number">1</span>) <span class="cm-keyword">return</span> <span class="cm-string">""</span>;
  <span class="cm-keyword">return</span> <span class="cm-variable-2">string</span>.<span class="cm-property">slice</span>(<span class="cm-variable-2">first</span>);
}

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">"# hello\nx"</span>));
<span class="cm-comment">// → {type: "word", name: "x"}</span>

<span class="cm-variable">console</span>.<span class="cm-property">log</span>(<span class="cm-variable">parse</span>(<span class="cm-string">"a # one\n   # two\n()"</span>));
<span class="cm-comment">// → {type: "apply",</span>
<span class="cm-comment">//    operator: {type: "word", name: "a"},</span>
<span class="cm-comment">//    args: []}</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_Q70JRSA+IN" href="#p_Q70JRSA+IN"></a>Asegúrese de que su solución maneja varios comentarios en una fila, pudiendo aparecer espacios en blanco entre o después de ellos.</p>
<p><a class=p_ident id="p_qxWOahcqHl" href="#p_qxWOahcqHl"></a>A regular expressionUna expresión regular es probablemente la manera más fácil de resolver esto. Escriba algo que coincida con "espacios en blanco o un comentario, cero o más veces". Utilice el método <code>exec</code> o <code>match</code> y observe la longitud del primer elemento del Array devuelto (la coincidencia completa) para averiguar cuántos caracteres quitar.</p>
</div></div>
<h3><a class=h_ident id="h_KZvWEETA3g" href="#h_KZvWEETA3g"></a>Fijando el alcance</h3>
<p><a class=p_ident id="p_Lw4SBw5i6s" href="#p_Lw4SBw5i6s"></a>Actualmente, la única forma de asignar una variable a un valor es <code>define</code>. Esta construcción actúa para definir nuevas variables como para dar a las existentes un nuevo valor.</p>
<p><a class=p_ident id="p_eG61iK1bZQ" href="#p_eG61iK1bZQ"></a>This ambiguityEsta ambigüedad causa un problema. Cuando intenta dar una variable no local un nuevo valor, terminará definiendo una en local con el mismo nombre en su lugar. (Algunos lenguajes funcionan de esta manera por diseño, pero siempre he encontrado una manera simple de manejar el alcance.)</p>
<p><a class=p_ident id="p_yxNUlrNNfr" href="#p_yxNUlrNNfr"></a>Agregue una functión especial <code>set</code>, similar a <code>define</code>, la cual da a una variable un nuevo valor, actualizando la variable en un ámbito externo si aún no existe en el ámbito interno. Si la variable no está definida en absoluto, lance un <code>ReferenceError</code> (El cual es otro tipo de error estándar).</p>
<p><a class=p_ident id="p_AZS37et2Ll" href="#p_AZS37et2Ll"></a>La técnica de representar los ámbitos como objetos simples, ha hecho las cosas convenientes hasta ahora, se pondrá en contra un poco en este punto. Es posible que desee utilizar la función <code>Object.getPrototypeOf</code>, que devuelve el prototipo de un objeto. También recuerde que los ámbitos no derivan de <code>Object.prototype</code>, así que si quieres llamar a <code>hasOwnProperty</code> en ellos, debes usar esta expresión:</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_EqqjVhV5wE" href="#c_EqqjVhV5wE"></a><span class="cm-variable">Object</span>.<span class="cm-property">prototype</span>.<span class="cm-property">hasOwnProperty</span>.<span class="cm-property">call</span>(<span class="cm-variable">scope</span>, <span class="cm-variable">name</span>);</pre>
<p><a class=p_ident id="p_JoemNNZnFW" href="#p_JoemNNZnFW"></a>Esto recupera el método <code>hasOwnProperty</code> del prototipo de <code>Object</code> y lo llama a un objeto scope.</p>
<pre data-language="javascript" class="snippet cm-s-default"><a class=c_ident id="c_TvhdgYJT/r" href="#c_TvhdgYJT/r"></a><span class="cm-variable">specialForms</span>[<span class="cm-string">"set"</span>] <span class="cm-operator">=</span> <span class="cm-keyword">function</span>(<span class="cm-def">args</span>, <span class="cm-def">env</span>) {
  <span class="cm-comment">// Your code here.</span>
};

<span class="cm-variable">run</span>(<span class="cm-string">"do(define(x, 4),"</span>,
    <span class="cm-string">"   define(setx, fun(val, set(x, val))),"</span>,
    <span class="cm-string">"   setx(50),"</span>,
    <span class="cm-string">"   print(x))"</span>);
<span class="cm-comment">// → 50</span>
<span class="cm-variable">run</span>(<span class="cm-string">"set(quux, true)"</span>);
<span class="cm-comment">// → Some kind of ReferenceError</span></pre>
<div class=solution><div class=solution-text>
<p><a class=p_ident id="p_fK9Bkc70cx" href="#p_fK9Bkc70cx"></a>Tendrá que realizar un bucle sobre un scope a la vez, utilizando <code>Object.getPrototypeOf</code> para ir al siguiente scope externo. Para cada scope, use <code>hasOwnProperty</code> para averiguar si la variable, indicada por la propiedad <code>name</code> del primer argumento de <code>set</code>, Si lo hace, póngalo en el resultado de evaluar el segundo argumento a <code>set</code> y luego devolver ese valor.</p>
<p><a class=p_ident id="p_CNWPW5cyt0" href="#p_CNWPW5cyt0"></a>Si alcanzamos el ámbito más alejado (<code>Object.getPrototypeOf</code> devuelve null) y no hemos encontrado la variable todavía, no existe, y se debe lanzar un error.</p>
</div></div>
<nav>
  <a href="10_modules.html" title="capítulo previo">◀</a>
  <a href="index.html" title="cover">◆</a>
  <a href="12_browser.html" title="capítulo siguiente">▶</a>
</nav>
</article>
